
<!DOCTYPE html>
<meta charset="utf-8">
<script src="//d3js.org/d3.v3.min.js"></script>
<script src="//d3js.org/queue.v1.min.js"></script>
<script src="//d3js.org/topojson.v1.min.js"></script>
<script src="js/d3.parcoords.js"></script>
<script src="js/divgrid.js"></script>
<link rel="stylesheet" href="css/d3.parcoords.css"></link>
<link rel="stylesheet" href="css/style.css"></link>

<div id="parcoords" class="parcoords" style="height:250px;"></div>
<div id="parcoords-grid"></div>
<svg id="map"></svg>
<svg id="state-grid" width=400 height=200></svg>

<script id="grid" type="text/plain">
                              ME
               WI          VT NH
WA ID MT ND MN IL MI    NY MA
OR NV WY SD IA IN OH PA NJ CT RI
CA UT CO NE MO KY WV VA MD DE
   AZ NM KS AR TN NC SC
         OK LA MS AL GA
HI AK    TX             FL
</script>

<script>
// Map setup
var mapsvg = d3.select("#map").append("g");
var bbox = d3.select("#map").node().getBoundingClientRect();
console.log("bbox", bbox)
var mapwidth = bbox.width;
var mapheight = bbox.height;
var scale0 = 1000;

var centered;
var selected;

var allCounties = []

var zoom = d3.behavior.zoom()
  .translate([mapwidth / 2, mapheight / 2])
  .scale(scale0)
  .scaleExtent([scale0, 10 * scale0])
  .on("zoom", zoomed);

var projection = d3.geo.albersUsa()
  .scale(scale0)
  .translate([mapwidth / 2, mapheight / 2]);

var path = d3.geo.path()
  .projection(projection);

function zoomed() {
  projection
    .translate(zoom.translate())
    .scale(zoom.scale());

  mapsvg.selectAll("path")
    .attr("d", path);

}

mapsvg.call(zoom)
</script>

<script src="js/stategrid.js"></script>

<script>
// DATA
queue()
    .defer(d3.json, "data/us-named.topojson")
    .defer(d3.csv, "data/counties-joined-2004.csv")
    //.defer(d3.csv, "data/counties-joined-2014.csv")
    .await(ready);

function ready(error, us, counties) {
  var states = topojson.feature(us, us.objects.states).features
  geoCounties = topojson.feature(us, us.objects.counties).features;
  countyHash = {}
  geoCounties.forEach(function(county) {
    countyHash[county.properties.id] = county; // string FIPS code: STXXX eg 13000 wher ST is state fips code
  })
  counties.forEach(function(county) {
    ch = countyHash[county.id]
    if(!ch) return;
    ch.properties = county; // string FIPS code: STXXX eg 13000 wher ST is state fips code
  })

  mapsvg
  .selectAll("path")
    .data(states)
  .enter().append("path").classed("state-boundary", true)
    .attr("d", path)

  var state = states.filter(function(d) {
    // list of state FIPS codes
    return d.id === 13; //Georgia
  })[0]
  console.log("georgia", state)
  clicked(state);


  /////////////////////////////////////////////////////////////////////////////
  // PARCOORDS
  var color = function(d) { return 'steelblue' };

  var parcoords = d3.parcoords()("#parcoords")
    .color(color)
    .alpha(0.4);

  parcoords
    .data(counties)
    .hideAxis(["name", "id"])
    .render()
    .brushMode("1D-axes");

  // create data table, row hover highlighting
  var grid = d3.divgrid();
  d3.select("#parcoords-grid")
    .datum(counties.slice(0,10))
    .call(grid)
    .selectAll(".row")
    .on({
      "mouseover": function(d) { parcoords.highlight([d]) },
      "mouseout": parcoords.unhighlight
    });

  // update data table on brush event
  parcoords.on("brush", function(d) {
    d3.select("#parcoords-grid")
      .datum(d.slice(0,10))
      .call(grid)
      .selectAll(".row")
      .on({
        "mouseover": function(d) { parcoords.highlight([d]) },
        "mouseout": parcoords.unhighlight
      });

    // dirty hack
    var k = 5.7
    var countyPaths = mapsvg
    	.selectAll("path.county")
      .style({
        stroke: "#111",
        "stroke-width": 1 / k
      })
      .filter(function(county) {
        return d.indexOf(county.properties) >= 0;
      })
      .style({
        stroke: "steelblue",
        "stroke-width": 3 / k
      })


  });
  /////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////
  // interaction on the map
  var countyPaths = mapsvg
  	.selectAll("path.county")
    .style({
      fill: function(d) {
        //return emscale(d.properties.employed)
        //return unscale(d.properties.unemployed)
        //return ratescale(d.properties.rate)
      }
    })
    .on("mouseover", function(d) {
      parcoords.highlight([d.properties])
    })
    .on("mouseout", function(d) {
      parcoords.unhighlight(d.properties)
    })
  /////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////
  // FORCE LAYOUT
  // starting with example from @mbostock http://bl.ocks.org/mbostock/3231298
  /*
  var nodes = d3.range(200).map(function() { return {radius: Math.random() * 12 + 4}; }),
      root = nodes[0],
      color = d3.scale.category10();

  root.radius = 0;
  root.fixed = true;

  var force = d3.layout.force()
      .gravity(0.05)
      .charge(function(d, i) { return i ? 0 : -2000; })
      .nodes(nodes)
      .size([width, height]);

  force.start();

  var svg = d3.select("body").append("svg")
      .attr("width", width)
      .attr("height", height);

  svg.selectAll("circle")
      .data(nodes.slice(1))
    .enter().append("circle")
      .attr("r", function(d) { return d.radius; })
      .style("fill", function(d, i) { return color(i % 3); });

  force.on("tick", function(e) {
    var q = d3.geom.quadtree(nodes),
        i = 0,
        n = nodes.length;

    while (++i < n) q.visit(collide(nodes[i]));

    svg.selectAll("circle")
        .attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });
  });

  svg.on("mousemove", function() {
    var p1 = d3.mouse(this);
    root.px = p1[0];
    root.py = p1[1];
    force.resume();
  });

  function collide(node) {
    var r = node.radius + 16,
        nx1 = node.x - r,
        nx2 = node.x + r,
        ny1 = node.y - r,
        ny2 = node.y + r;
    return function(quad, x1, y1, x2, y2) {
      if (quad.point && (quad.point !== node)) {
        var x = node.x - quad.point.x,
            y = node.y - quad.point.y,
            l = Math.sqrt(x * x + y * y),
            r = node.radius + quad.point.radius;
        if (l < r) {
          l = (l - r) / l * .5;
          node.x -= x *= l;
          node.y -= y *= l;
          quad.point.x += x;
          quad.point.y += y;
        }
      }
      return x1 > nx2 || x2 < nx1 || y1 > ny2 || y2 < ny1;
    };
  }
  */

  /////////////////////////////////////////////////////////////////////////////

}

</script>
